public class HugeInteger {
	private int sign_int; 
	private int[] digits_int;
	
	public HugeInteger(String val) throws IllegalArgumentException, NullPointerException{
		
		//PART I - ERROR HANDLING AND EXCEPTIONS
		
		//Null pointer exception
		if(val.length()==0 || val==null) {    //Checking if string is null
			throw new NullPointerException ("The string val cannot be null");
		}
		
		//Creating char arrays to check if the inputs are valid
		String valid_str = "0123456789";   //Character array to check for valid characters
		char[] valid  = valid_str.toCharArray();
		char[] valc = val.toCharArray();
		
		//Checking if the number is negative or positive
		int ind = 0; 
		
		if(valc[0]=='-' && valc.length==1) {   //checking the valc length and invalid sign
			throw new IllegalArgumentException("The string has to contain numbers");
		}
		
		if(valc[0]=='-' && valc.length>1) {   //if there is a sign and number
			ind = 1;
		}
		
		//Checking for invalid inputs -> two for loops an matching the characters
		for (int i=ind;i<valc.length;i++) {
			int check = 0;
			for(int j=0; j<valid.length;j++) {
				if(valc[i]==valid[j]) {
					check = 1;
				}
			}
			
			if(check==0){
				throw new IllegalArgumentException("Illegal Arguments");
			}
		}
			
		//PART II - sign_int ASSIGNMNET
		
		//Takes the sign of the HugeInteger: 1,-1,0
		
		sign_int = -1;
		
		if(valc[0]!='-') {
			sign_int = 1;
		}
		
		if(valc.length==1 && valc[0]=='0') {
			sign_int = 0;
			digits_int = new int[1];
			digits_int[0] = 0;
		}
		
		int num_zero = 0;   //checks the number of zeros
		
		for(int i=ind; i<valc.length; i++) {
			if(valc[i]=='0') {
				num_zero++;
			}
		}
		
		int all_zero=0; //Checks if all the digits in the string are zero
		
		if(num_zero==valc.length || valc[0]=='-' && num_zero==valc.length-1) {
			all_zero=1;
			sign_int = 0;
			digits_int = new int[1];
			digits_int[0] = 0;
			
		}
	
		//PART III - LOADING DIGITS INTO digits_int
		
		//Appending other digits to digits_int
		
		int pos = 0;
		int leadZero_occur = 0;
		int leadZero_pos = 0;
		
		//Calculating the number of leading zeros
		for(int i=0; i<valc.length; i++) {
			if(valc.length!= 1 && valc[0]=='0' && i!= valc.length-1 || valc.length!= 1 && valc[1]=='0' && i!= valc.length-1 && valc[0] == '-'){ //Checking for sign and leading zeros
				if(valc[i]=='0' && valc[i+1]!='0') {
					leadZero_occur = 1;
					leadZero_pos = i;
					break;
				}
			}
		}
		
		if (leadZero_occur==1 && valc[0]!='-') {  //Counting leading zeros if the first sign is not negative
			leadZero_occur = leadZero_pos+1;
		}
		
		if (leadZero_occur==1 && valc[0]=='-') { //Counting leading zeros if the sign is negative
			leadZero_occur = leadZero_pos;
		}
		
		//Removing all the leading zeros
		if(leadZero_occur>=1) {
			digits_int = new int[valc.length - leadZero_occur];
			for (int i=leadZero_occur; i<valc.length; i++) {
				digits_int[pos] = Integer.parseInt(String.valueOf(valc[i]));
				pos++;
			}
		}
		
		//In case of no leading zeros appending everything to the array
		else if(all_zero!=1) {
			int len = valc.length;
			if(ind==1) {
				len = valc.length-1;
			}
			
			digits_int = new int[len];
			for (int i=ind; i<valc.length; i++) {
				digits_int[pos] = Integer.parseInt(String.valueOf(valc[i]));
				pos++;
			}
		}
		
	}
	
	public HugeInteger(int n) throws IllegalArgumentException{ //Ask if this constructor can generate negative numbers as well
		
		//Checking if n<=0 and throwing exception
		if(n<=0) {
			throw new IllegalArgumentException("n should be above zero");
		}
		
		sign_int = 1;
		
		//sign
		/*int sign[] = new int[2];
		
		sign[0] = 1;
		sign[1] = -1;
		
		int sign_ind = (int) ((Math.random()*2));
		
		sign_int = sign[sign_ind];*/
		
		digits_int = new int[n];
		
		digits_int[0] = 1 + (int) ((Math.random()*9)) ; //Making the first digit not equal to zero
		
		for(int pos=1; pos<n; pos++) {
			digits_int[pos] = (int) ((Math.random()*10)); //All other digits can be equal to zero
		}
		
	}
	
	public int get_Size() {
		return this.digits_int.length;
	}
	
	public int get_Sign() {
		return this.sign_int;
	}
	
	public HugeInteger add(HugeInteger h) {
		int len = this.get_Size();
		
		if(h.get_Size()>this.get_Size()) {
			len = h.get_Size();
		}
		
		HugeInteger  add_int = new HugeInteger(len+1);
		add_int.sign_int = 1; //only dealing with positive numbers
		
		int carry = 0;
		int sum = 0;
		int ind_add = add_int.get_Size()-1;  //starting from back traversing to the front
		if(this.get_Size() == h.get_Size()) {
			for(int pos=len-1; pos>=0; pos--) {
				sum = this.digits_int[pos] + h.digits_int[pos] + carry;
				
				add_int.digits_int[ind_add] = sum%10;
				ind_add--;
				carry = sum/10;
			}
			
			add_int.digits_int[0] = carry;
		}
		
		if(this.get_Size()>h.get_Size()) {
			int ind_1 = this.get_Size()-1;
			for(int pos= h.get_Size()-1; pos>=0; pos--) {
				sum = this.digits_int[ind_1] + h.digits_int[pos] + carry;
				
				add_int.digits_int[ind_add] = sum%10;
				ind_add--;
				carry = sum/10;
				ind_1--;
			}
			
			for(int pos = ind_1; pos>=0; pos--) {
				sum = this.digits_int[pos] + carry;
				
				add_int.digits_int[ind_add] = sum%10;
				ind_add--;
				carry = sum/10;
			}
			
			add_int.digits_int[0] = carry;
		}
		
		if(h.get_Size()>this.get_Size()) {
			int ind_1 = h.get_Size()-1;
			for(int pos= this.get_Size()-1; pos>=0; pos--) {
				sum = this.digits_int[pos] + h.digits_int[ind_1] + carry;
				
				add_int.digits_int[ind_add] = sum%10;
				ind_add--;
				carry = sum/10;
				ind_1--;
			}
			
			for(int pos = ind_1; pos>=0; pos--) {
				sum = h.digits_int[pos] + carry;
				
				add_int.digits_int[ind_add] = sum%10;
				ind_add--;
				carry = sum/10;
			}
			
			add_int.digits_int[0] = carry;
		}
		
		if(add_int.digits_int[0] ==  0) {  //if carry is zero making a new hugeint number
			int init_len = 0;
			
			for (int ind=0; ind<add_int.get_Size()-1; ind++) {
				init_len += 1;
			}
			
			HugeInteger add_lead_int = new HugeInteger(init_len);
			add_lead_int.sign_int = 1;
			int pos_new = 0;
			
			for(int pos=1; pos<add_int.get_Size(); pos++) {
				add_lead_int.digits_int[pos_new] = add_int.digits_int[pos];
				pos_new++;
			}
			
			return add_lead_int;
		}
		
		return add_int;
	}
	
	public String toString() {
		String huge_int = String.valueOf(sign_int*digits_int[0]);
		for(int pos=1; pos<digits_int.length;pos++) {
			huge_int += String.valueOf(digits_int[pos]);
		}
		return huge_int;
	}

}